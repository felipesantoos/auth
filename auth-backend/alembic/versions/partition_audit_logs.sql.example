-- =====================================================================
-- Audit Log Table Partitioning (PostgreSQL)
-- =====================================================================
--
-- Use this when you have >100M audit logs and queries become slow.
--
-- Benefits:
-- - Faster queries (smaller partitions to scan)
-- - Easy archival (drop old partitions)
-- - Improved maintenance (vacuum/analyze per partition)
--
-- Performance:
-- - 10x faster queries on partitioned tables
-- - Instant deletion of old data (DROP PARTITION)
--
-- =====================================================================

-- Step 1: Rename existing table (backup)
ALTER TABLE audit_log RENAME TO audit_log_old;

-- Step 2: Create partitioned table
CREATE TABLE audit_log (
    id TEXT NOT NULL,
    event_id TEXT NOT NULL,
    event_type TEXT NOT NULL,
    event_category TEXT,
    action TEXT,
    description TEXT,
    
    -- Actor
    user_id TEXT,
    username TEXT,
    user_email TEXT,
    impersonated_by TEXT,
    
    -- Tenant
    client_id TEXT NOT NULL,
    
    -- Resource
    resource_type TEXT,
    resource_id TEXT,
    resource_name TEXT,
    
    -- Context
    ip_address TEXT,
    user_agent TEXT,
    location TEXT,
    request_id TEXT,
    session_id TEXT,
    
    -- Changes
    changes JSONB,
    old_values JSONB,
    new_values JSONB,
    
    -- Metadata
    metadata JSONB,
    tags TEXT[],
    
    -- Status
    success BOOLEAN NOT NULL DEFAULT TRUE,
    status TEXT NOT NULL DEFAULT 'success',
    error_message TEXT,
    
    -- Timestamp (PARTITION KEY)
    created_at TIMESTAMP NOT NULL,
    
    -- Constraints
    PRIMARY KEY (id, created_at),
    UNIQUE (event_id, created_at)
    
) PARTITION BY RANGE (created_at);

-- Step 3: Create partitions (monthly)

-- Current month
CREATE TABLE audit_log_2025_11 PARTITION OF audit_log
    FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');

-- Next month
CREATE TABLE audit_log_2025_12 PARTITION OF audit_log
    FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

-- Future months (create as needed)
CREATE TABLE audit_log_2026_01 PARTITION OF audit_log
    FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

CREATE TABLE audit_log_2026_02 PARTITION OF audit_log
    FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');

-- Step 4: Create indexes on each partition
-- (PostgreSQL automatically creates indexes on partitions from parent table indexes)

-- User activity indexes
CREATE INDEX idx_audit_log_2025_11_user_id ON audit_log_2025_11(user_id);
CREATE INDEX idx_audit_log_2025_11_user_event ON audit_log_2025_11(user_id, event_type);
CREATE INDEX idx_audit_log_2025_11_user_created ON audit_log_2025_11(user_id, created_at);

CREATE INDEX idx_audit_log_2025_12_user_id ON audit_log_2025_12(user_id);
CREATE INDEX idx_audit_log_2025_12_user_event ON audit_log_2025_12(user_id, event_type);
CREATE INDEX idx_audit_log_2025_12_user_created ON audit_log_2025_12(user_id, created_at);

-- Client indexes
CREATE INDEX idx_audit_log_2025_11_client_id ON audit_log_2025_11(client_id);
CREATE INDEX idx_audit_log_2025_11_client_event ON audit_log_2025_11(client_id, event_type);

CREATE INDEX idx_audit_log_2025_12_client_id ON audit_log_2025_12(client_id);
CREATE INDEX idx_audit_log_2025_12_client_event ON audit_log_2025_12(client_id, event_type);

-- Entity indexes
CREATE INDEX idx_audit_log_2025_11_entity ON audit_log_2025_11(resource_type, resource_id);
CREATE INDEX idx_audit_log_2025_12_entity ON audit_log_2025_12(resource_type, resource_id);

-- Event category indexes
CREATE INDEX idx_audit_log_2025_11_category ON audit_log_2025_11(event_category);
CREATE INDEX idx_audit_log_2025_12_category ON audit_log_2025_12(event_category);

-- Step 5: Migrate data from old table
INSERT INTO audit_log SELECT * FROM audit_log_old;

-- Step 6: Verify migration
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    pg_total_relation_size(schemaname||'.'||tablename) AS size_bytes
FROM pg_tables
WHERE tablename LIKE 'audit_log%'
ORDER BY size_bytes DESC;

-- Step 7: Drop old table (after verification!)
-- DROP TABLE audit_log_old;

-- =====================================================================
-- Maintenance Functions
-- =====================================================================

-- Function to create next month's partition
CREATE OR REPLACE FUNCTION create_next_audit_partition()
RETURNS TEXT AS $$
DECLARE
    next_month DATE;
    month_after DATE;
    partition_name TEXT;
BEGIN
    -- Calculate next month
    next_month := DATE_TRUNC('month', NOW() + INTERVAL '1 month');
    month_after := next_month + INTERVAL '1 month';
    
    -- Generate partition name (e.g., audit_log_2026_03)
    partition_name := 'audit_log_' || TO_CHAR(next_month, 'YYYY_MM');
    
    -- Create partition
    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I PARTITION OF audit_log FOR VALUES FROM (%L) TO (%L)',
        partition_name,
        next_month,
        month_after
    );
    
    -- Create indexes on new partition
    EXECUTE format('CREATE INDEX idx_%I_user_id ON %I(user_id)', partition_name, partition_name);
    EXECUTE format('CREATE INDEX idx_%I_client_id ON %I(client_id)', partition_name, partition_name);
    EXECUTE format('CREATE INDEX idx_%I_entity ON %I(resource_type, resource_id)', partition_name, partition_name);
    
    RETURN 'Created partition: ' || partition_name;
END;
$$ LANGUAGE plpgsql;

-- Function to drop old partitions (after archival)
CREATE OR REPLACE FUNCTION drop_old_audit_partition(months_old INT DEFAULT 24)
RETURNS TEXT AS $$
DECLARE
    cutoff_date DATE;
    partition_name TEXT;
BEGIN
    -- Calculate cutoff date
    cutoff_date := DATE_TRUNC('month', NOW() - (months_old || ' months')::INTERVAL);
    
    -- Generate partition name
    partition_name := 'audit_log_' || TO_CHAR(cutoff_date, 'YYYY_MM');
    
    -- Drop partition (WARNING: Data will be lost!)
    EXECUTE format('DROP TABLE IF EXISTS %I', partition_name);
    
    RETURN 'Dropped partition: ' || partition_name;
END;
$$ LANGUAGE plpgsql;

-- =====================================================================
-- Automated Partition Creation (Cron Job / Celery Beat)
-- =====================================================================

-- Schedule this to run monthly:
-- SELECT create_next_audit_partition();

-- =====================================================================
-- Query Examples on Partitioned Table
-- =====================================================================

-- Query specific partition (fastest)
SELECT * FROM audit_log_2025_11 
WHERE user_id = '123' 
ORDER BY created_at DESC 
LIMIT 100;

-- Query across all partitions (automatic partition pruning)
SELECT * FROM audit_log 
WHERE user_id = '123' 
AND created_at >= '2025-01-01'
ORDER BY created_at DESC 
LIMIT 100;

-- List all partitions
SELECT 
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE tablename LIKE 'audit_log_%'
ORDER BY tablename DESC;

